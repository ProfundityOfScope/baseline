"""Earth Orientation Parameter (EOP) estimation from VLBI data"""import numpy as npimport pandas as pdfrom typing import Dict, List, Optional, Tuple, Anyimport warningsclass EOPEstimator:    """    Earth Orientation Parameter estimator using VLBI delay observations        This class implements weighted least squares estimation of EOPs from    VLBI group delay observations using pre-computed partial derivatives.    """        def __init__(self, analysis_interface):        """        Initialize EOP estimator                Parameters        ----------        analysis_interface : AnalysisInterface            Interface to vgosDB data        """        self.data = analysis_interface            def estimate_eop(self,                      solve_for: List[str] = ['UT1', 'x_pole', 'y_pole'],                     band: str = 'X',                     outlier_threshold: float = 3.0) -> Dict[str, Any]:        """        Estimate Earth Orientation Parameters using weighted least squares                The fundamental equation is:        Δτ_obs - Δτ_theo = Σ (∂τ/∂p_i) * Δp_i + ε                Where:        - Δτ_obs, Δτ_theo are observed and theoretical delays        - ∂τ/∂p_i are partial derivatives w.r.t. parameter i        - Δp_i are parameter corrections we're solving for        - ε is the observation noise                Parameters        ----------        solve_for : list of str            Parameters to estimate. Options: 'UT1', 'x_pole', 'y_pole'        band : str            Frequency band to use ('X' or 'S')        outlier_threshold : float            Sigma threshold for outlier detection                    Returns        -------        dict            Dictionary containing:            - eop_values: Estimated EOP values              - uncertainties: Formal uncertainties            - covariance: Parameter covariance matrix            - residuals: Post-fit residuals            - statistics: Fit statistics        """                # Get the observational data        try:            obs = self.data.get_observations(band=band)            partials = self.data.get_eop_partials()            apriori_eop = self.data.get_a_priori_eop()        except Exception as e:            raise ValueError(f"Could not load required data: {e}")                if len(obs) == 0:            raise ValueError("No observations found")                    print(f"Loaded {len(obs)} observations for EOP estimation")                # Form observation equations: O - C = A * x + ε        observed_minus_computed = obs['delay_obs'].values - obs['delay_theo'].values                # Build design matrix from partials        A = self._build_design_matrix(partials, solve_for, len(obs))                # Initial outlier detection based on O-C        good_obs = self._detect_outliers(observed_minus_computed, obs['delay_sigma'].values,                                        outlier_threshold)                if np.sum(good_obs) < len(solve_for):            warnings.warn(f"Only {np.sum(good_obs)} good observations, but solving for {len(solve_for)} parameters")                # Apply outlier mask        omc_clean = observed_minus_computed[good_obs]        A_clean = A[good_obs, :]        sigma_clean = obs['delay_sigma'].values[good_obs]                # Weight matrix from observation uncertainties        W = np.diag(1.0 / sigma_clean**2)                # Weighted least squares solution: x = (A^T W A)^(-1) A^T W (O-C)        try:            AtWA = A_clean.T @ W @ A_clean            AtW_OmC = A_clean.T @ W @ omc_clean                        # Solve normal equations            eop_corrections = np.linalg.solve(AtWA, AtW_OmC)                        # Compute covariance matrix            covariance = np.linalg.inv(AtWA)            uncertainties = np.sqrt(np.diag(covariance))                    except np.linalg.LinAlgError as e:            raise ValueError(f"Singular normal matrix - cannot solve for EOPs: {e}")                # Apply corrections to a priori values        final_eop = self._apply_corrections(apriori_eop, eop_corrections, solve_for, obs)                # Compute post-fit residuals and statistics        residuals_clean = omc_clean - A_clean @ eop_corrections        chi_squared = np.sum((residuals_clean / sigma_clean)**2)        reduced_chi_squared = chi_squared / (len(residuals_clean) - len(solve_for))                # Compute full residual vector (including outliers as large residuals)        predicted = A @ eop_corrections        full_residuals = observed_minus_computed - predicted                # Create results dictionary        results = {            'eop_values': final_eop,            'corrections': dict(zip(solve_for, eop_corrections)),            'uncertainties': dict(zip(solve_for, uncertainties)),            'covariance': covariance,            'parameter_names': solve_for,            'residuals': full_residuals,            'residuals_clean': residuals_clean,            'good_observations': good_obs,            'statistics': {                'n_observations_total': len(obs),                'n_observations_used': len(residuals_clean),                'n_parameters': len(solve_for),                'degrees_of_freedom': len(residuals_clean) - len(solve_for),                'chi_squared': chi_squared,                'reduced_chi_squared': reduced_chi_squared,                'rms_residual_ns': np.std(residuals_clean) * 1e9,                'weighted_rms_ns': np.sqrt(chi_squared / len(residuals_clean)) * 1e9            },            'observations': obs  # Include for plotting/analysis        }                return results        def _build_design_matrix(self, partials: Dict[str, np.ndarray],                            solve_for: List[str], n_obs: int) -> np.ndarray:        """        Build design matrix from partial derivatives                Parameters        ----------        partials : dict            Dictionary of partial derivatives        solve_for : list            Parameters to solve for        n_obs : int            Number of observations                    Returns        -------        np.ndarray            Design matrix A [n_obs x n_params]        """        n_params = len(solve_for)        A = np.zeros((n_obs, n_params))                for i, param in enumerate(solve_for):            if param == 'UT1':                # Use delay partial (index 0), not rate partial (index 1)                A[:, i] = partials['ut1_partials'][0, :]  # [delay, rate] -> delay only            elif param == 'x_pole':                A[:, i] = partials['xpole_partials'][0, :]            elif param == 'y_pole':                  A[:, i] = partials['ypole_partials'][0, :]            else:                raise ValueError(f"Unknown parameter: {param}")                        return A        def _detect_outliers(self, residuals: np.ndarray, sigmas: np.ndarray,                         threshold: float) -> np.ndarray:        """        Simple outlier detection based on normalized residuals                Parameters        ----------        residuals : np.ndarray            O-C residuals        sigmas : np.ndarray            Observation uncertainties        threshold : float            Sigma threshold for outlier rejection                    Returns        -------        np.ndarray            Boolean mask of good observations        """        normalized_residuals = np.abs(residuals) / sigmas        good_obs = normalized_residuals < threshold                n_outliers = np.sum(~good_obs)        if n_outliers > 0:            print(f"Detected {n_outliers} potential outliers (>{threshold:.1f}σ)")                    return good_obs        def _apply_corrections(self, apriori_eop: Dict[str, np.ndarray],                           corrections: np.ndarray, solve_for: List[str],                          obs: pd.DataFrame) -> Dict[str, float]:        """        Apply estimated corrections to a priori EOP values                Parameters        ----------        apriori_eop : dict            A priori EOP values        corrections : np.ndarray            Estimated parameter corrections        solve_for : list            Parameter names        obs : pd.DataFrame            Observation data for time reference                    Returns        -------        dict            Final EOP values        """        # For simplicity, use the mean epoch of observations        # In practice, you'd want to interpolate/extrapolate properly        mean_time = obs['time_mjd'].mean()                # Find closest a priori epoch (simplified)        if len(apriori_eop['time_mjd']) > 0:            closest_idx = np.argmin(np.abs(apriori_eop['time_mjd'] - mean_time))                        final_eop = {                'epoch_mjd': mean_time,                'UT1': apriori_eop['ut1'][closest_idx] if 'UT1' not in solve_for                        else apriori_eop['ut1'][closest_idx] + corrections[solve_for.index('UT1')],                'x_pole': apriori_eop['x_pole'][closest_idx] if 'x_pole' not in solve_for                         else apriori_eop['x_pole'][closest_idx] + corrections[solve_for.index('x_pole')],                'y_pole': apriori_eop['y_pole'][closest_idx] if 'y_pole' not in solve_for                           else apriori_eop['y_pole'][closest_idx] + corrections[solve_for.index('y_pole')]            }        else:            # No a priori values - start from zero (not realistic but functional)            final_eop = {                'epoch_mjd': mean_time,                'UT1': corrections[solve_for.index('UT1')] if 'UT1' in solve_for else 0.0,                'x_pole': corrections[solve_for.index('x_pole')] if 'x_pole' in solve_for else 0.0,                'y_pole': corrections[solve_for.index('y_pole')] if 'y_pole' in solve_for else 0.0            }                    return final_eop        def plot_residuals(self, results: Dict[str, Any]) -> None:        """        Plot post-fit residuals (requires matplotlib)                Parameters        ----------        results : dict            Results from estimate_eop()        """        try:            import matplotlib.pyplot as plt        except ImportError:            print("Matplotlib not available for plotting")            return                    obs = results['observations']        residuals = results['residuals']        good_obs = results['good_observations']                fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))                # Residuals vs time        ax1.scatter(obs['time_mjd'][good_obs], residuals[good_obs] * 1e9,                    alpha=0.7, label='Used')        if np.sum(~good_obs) > 0:            ax1.scatter(obs['time_mjd'][~good_obs], residuals[~good_obs] * 1e9,                       color='red', alpha=0.7, label='Outliers')        ax1.set_xlabel('Time (MJD)')        ax1.set_ylabel('Residuals (ns)')        ax1.set_title('Post-fit Residuals vs Time')        ax1.legend()        ax1.grid(True, alpha=0.3)                # Residual histogram        ax2.hist(residuals[good_obs] * 1e9, bins=20, alpha=0.7, edgecolor='black')        ax2.set_xlabel('Residuals (ns)')        ax2.set_ylabel('Count')        ax2.set_title('Residual Distribution')        ax2.grid(True, alpha=0.3)                plt.tight_layout()        plt.show()                # Print some statistics        print(f"\nResidual Statistics:")        print(f"RMS: {results['statistics']['rms_residual_ns']:.2f} ns")        print(f"Weighted RMS: {results['statistics']['weighted_rms_ns']:.2f} ns")        print(f"Reduced χ²: {results['statistics']['reduced_chi_squared']:.2f}")